#################################################################
#  diagnostics.R
#
#  This script brings in required libraries and defines functions
#     for diagnostic outputs
#  - Ultimately these will be hidden in a package
#
#  Includes:
#   1) generateLiftTable()
#   2) plotCumLift()
#   3) plotPctResponse()
#   4) generateCorrelationMatrix()
#   5) generateReducedCorrelationMatrix() -- omits variables with no high correlations
#   6) generateVIF()
#   7) generateCI()
#   8) plotImportance()
#   9) generateConfusionMatrix()
#
#################################################################


## Load required libraries if not loaded
if(!require(dplyr)){
  install.packages("dplyr")
  library(dplyr)
}
if(!require(ggplot2)){
  install.packages("ggplot2")
  library(ggplot2)
}
if(!require(mltools)){
  install.packages("mltools")
  library(mltools)
}
if(!require(fmsb)){
  install.packages("fmsb")  # alternate method for vif
  library(fmsb)
}
if(!require(car)){
  install.packages("car")  #needed for vif()
  library(car)
}
if(!require(perturb)){
  install.packages("perturb") # needed for CI  colldiag()
  library(perturb)
}

#### lift table function -------------------------------------------
# adapted from https://www.listendata.com/2015/06/r-function-gain-and-lift-table.html
# Outputs a table with lift metrics by decile
# Requires:
#   actual    - vector of actual results (y)
#   predicted - vector of predicted results (y-hat)
#
generateLiftTable <- function(actual, predicted) {
  groups <- 10 # chart by decile

  if(is.factor(actual)) actual <- as.integer(as.character(actual))
  if(is.factor(predicted)) predicted <- as.integer(as.character(predicted))
  helper = data.frame(cbind(actual, predicted))
  helper[,"bucket"] = ntile(-helper[,"predicted"], groups)
  gaintable = helper %>% group_by(bucket)  %>%
    summarise_at(vars(actual), funs(total = n(),
                                    totalresp=sum(., na.rm = TRUE))) %>%
    mutate(Cumresp = cumsum(totalresp),
           Gain=Cumresp/sum(totalresp)*100,
           Cumlift=Gain/(bucket*(100/groups)))
  return(gaintable)
} # end of generateLiftTable()



#### Plot Cumulative Lift Graph-------------------------------------
# Outputs an object with a ggplot of cumulative lift
# Requires:
#   liftTable - lift table (ie, one generated by generateLiftTable())
# Optional:
#   chartTitle - Title for plot
#
plotCumLift <- function(liftTable, chartTitle = NULL){
  cumLift <- ggplot(liftTable, aes(bucket, Cumlift)) +
    geom_line() +
    labs(x = "Decile",
         y = "Lift Value, Cumulative",
         title = chartTitle,
         subtitle = "Lift Value"
    ) +
    scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10))
  return(cumLift)
} # end of plotCumLift()


#### Plot Percent Response Graph-------------------------------------
# Outputs an object with a ggplot of % Captured Response vs Decile
# Requires:
#   liftTable - lift table (ie, one generated by generateLiftTable())
# Optional:
#   chartTitle - Title for plot
#
plotPctResponse <- function(liftTable, chartTitle = NULL){
  pctResponse <- ggplot(liftTable, aes(bucket, Gain))+
    geom_line() +
    labs(x = "Decile",
         y = "% Captured Response, Cumulative",
         title = chartTitle,
         subtitle = "% Captured Response"
    ) +
    scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10))
  return(pctResponse)
} # end of plotPctResponse()



#### Full Correlation Matrix-------------------------------------
# Outputs a data frame containing correlation matrix
# Requires:
#   df - dataframe containing variable data (ie train)
#
generateCorrelationMatrix <- function(df, depvars){
  cormatrix <- data.frame(cor(select(df, depvars)))
  cormatrix <- round(cormatrix, 4)
  cormatrix[upper.tri(cormatrix)] <- ""  # remove upper triangle
  cormatrix <- tibble::rownames_to_column(cormatrix, var=" ")
} # end of generateCorrelationMatrix()


#### Reduced Correlation Matrix ------------------------------
# Outputs a data frame containing reduced correlation matrix
#   - Variables with no correlations above the specified threshold are omitted
#   - All relevant variables represented by rows
#   - Columns only included if the column includes correlation geater than threshold
# Requires:
#   df - dataframe containing variable data (ie train)
# Optional:
#   threshold - numeric value used for omitting irrelevant variables from result
#
generateReducedCorrelationMatrix <- function(df, depvars, threshold=0.5){
  full <- cor(select(df, depvars))
  tmp <- full
  diag(tmp) <- NA
  tmp <- apply(tmp, 2, function(x) { x[abs(x) < threshold] <- NA; x}) # recode everything lower than 0.5 to NA
  # identify rows/columns with relevant values
  rowsWithCorr <- apply(tmp, 1, function(x) !all(is.na(x)))
  colsWithCorr <- apply(tmp, 2, function(x) !all(is.na(x)))
  rcm <- tmp[rowsWithCorr, colsWithCorr]
  rcm[upper.tri(rcm, diag=TRUE)] <- NA # remove upper triangle and diagonal
  emptyCols <- apply(rcm, 2, function(x) all(is.na(x)))
  #diag(rcm) <- 1 # put the diagonal back in for readability
  rcm <- rcm[, !emptyCols]  #remove empty columns.  Leaving empty rows in for readability
  rcm <- data.frame(round(rcm, 4))
  rcm <- tibble::rownames_to_column(rcm, var = " ")
  return(rcm)
} # end of Reduced Correlation Matrix



#  VIF relates to how the other independent variables might predict the one in question
#  VIF = 1 / (1 - R2)
#  According to Penn State, VIFs:
#   exceeding 4 warrant further investigation.
#   exceeding 10 are a sign of serious multicollinearity
#
# Requires:
#   df.x - data.frame with x components of glm
# Optional:
#   threshold - VIF above which values should be called out
# Returns:
#   list containing
#     full = VIF computation for full set
#     problem = Subset of VIF's >= threshold
#
generateVIF <- function(df.x,threshold=4){
  vif_init <- data.frame(var=character(), vif=numeric())
  problems <- data.frame(var=character(), vif=numeric())
  var_names <- names(df.x)
  
  if(any(!'data.frame' %in% class(df.x))) df.x<-data.frame(df.x)
  
  #Check for null values
  #if(any(apply(df.x,2,function(x) any(is.na(x))))) { ... }
  
  #get initial vif value for all comparisons of variables
  for(val in var_names){
    regressors <- var_names[-which(var_names == val)]
    form <- paste(regressors, collapse = '+')
    form_in <- formula(paste(val, '~', form))
    vif_init <- rbind(vif_init, data.frame(var=val, vif=fmsb::VIF(lm(form_in, data = df.x))))
  }
  vif_max <- max(vif_init$vif, na.rm = TRUE)
  

  #backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
  while(vif_max >= threshold){
    message(paste0("Columns to check: ",ncol(df.x)))
    vif_vals <- data.frame(var=character(), vif=numeric())
    var_names <- names(df.x)
    
    for(val in var_names){ #regress each variable against the rest.  Record the VIF (1 / (1-r^2) for the model)
      regressors <- var_names[-which(var_names == val)]
      form <- paste(regressors, collapse = '+')
      form_in <- formula(paste(val, '~', form))
      vif_vals <- rbind(vif_vals, data.frame(var=val, vif=fmsb::VIF(lm(form_in, data = df.x))))
    }
    vif_max <- max(vif_vals$vif, na.rm = TRUE)
    max_row <- vif_vals[!is.na(vif_vals$vif) & vif_vals$vif == vif_max,] #identify variable with highest VIF
    
    message(paste0("Max VIF found in this iteration: ",max_row$vif," - ",max_row$var))
    if(vif_max < threshold) break
    
    problems <- rbind(problems, max_row) #if highest VIF is higher than threshold, add it to the problems
    df.x <- df.x[,!names(df.x) %in% max_row$var]
  }
    #return(names(df.x))
  problem.list <- as.numeric(problems$vif)
  names(problem.list) <- problems$var
  full.list <- as.numeric(vif_init$vif)
  names(full.list) <- vif_init$var
  return(list(full=full.list,problem=problem.list))
} # end of generateVIF()


## Condition Index
# CI = sqrt( (largest eigenvalue) / (beta eigenvalue))
# SAS documentation on prog reg suggests CI:
#   greater than 10 is sign of dependencies
#   greater than 30 is rule-of-thumb bad
#   greater then 100 is a sign of a fair amount of numerical error (statistical error is higher than numerical error)
# For variable proportions, 0.5 and greater indicates collinearity
# Collinearity with the intercept indicates that the variable is close to constant
#
# Requires:
#   model - output model from glm (does not work with LASSO/RIDGE)
# Optional:
#   threshold - CI above which values should be called out
#
generateCI <- function(model, threshold = 30){
  tmp <- colldiag(model)
  full <- data.frame(cbind(tmp$condindx, tmp$pi))
  full <- round(full, 4)
  problem <- full[full$cond.index >= 10, ]
  problemColumns <- apply(problem, 2, function(x) any(x > 0.4))
  problem <- problem[problemColumns]
  return(list(full=full, problem=problem))
} # end of generateCI()




#### not used - created for models run in interactive mode.  May revisit.
# Interactive Diagnostics
diagnostics <- function(actual, predicted, chartTitle=NULL){
  liftTable <- generateLiftTable(actual, predicted)
  cumLift <- plotCumLift(liftTable, chartTitle)
  pctResponse <- plotPctResponse(liftTable, chartTitle)
  auc <- auc_roc(preds = predicted, actuals=actual) #bigger is better
  
  return(list(liftTable = liftTable, 
              cumLift = cumLift, 
              pctResponse = pctResponse,
              auc = auc
              )
  )
} # end of diagnostics()

#### Plot Variable Importance Graph-------------------------------------
# Outputs an object with a ggplot of Ordered variable importance
# Requires:
#   df - data frame with variables and numeric importance value
# Optional:
#   chartTitle - Title for plot
#
plotVarImportance <- function(df, chartTitle = NULL){
  imp <- ggplot(df, aes(x=reorder(variable, Importance, fill="blue"), y=Importance)) + 
    geom_bar(stat = 'identity', fill="blue", width = 0.5) +
    coord_flip() +
    theme(text = element_text(size=8)) +
    labs(x = "Variable",
         y="",
         title = chartTitle,
         subtitle = "Variable Importance"
    )
  return(imp)
} # end of plotVarImportance()


#### Generate Confusion Matrix  -------------------------------------
# Outputs an 2x2 Confusion Matrix
# Requires:
#   actual    - vector of actual values
#   predicted - vector of predicted values
# Optional:
#   cutoff    - cutoff value for rounding predicted probabilities
#
# Returns:
#   named list containing:
#     cm          - Table object containing confusion matrix
#     sensitivity - ratio of True Positive / Actual Positive
#     specificity - ratio of True Negative / Actual Negative
#     ppv         - Positive Predictive Value; ratio of True Positive / Predicted Positive
#     npv         - Negative Predictive Value; ratio of True Negative / Predicted Negative
#     accuracy    - ratio of (True Positive + True Negative) / Population
#
generateConfusionMatrix <- function(actual, predicted, cutoff=0.5){
  predicted.cutoff <- ifelse(predicted > cutoff,1,0)
  predicted.factor <- factor(predicted.cutoff, levels=c(1,0), labels=c("YES","NO"))
  actual.factor <- factor(actual, levels=c(1,0), labels=c("YES","NO"))
  cm <- table(actual.factor, predicted.factor, dnn=c("Actual", "Predicted"))
  cm.df <- as.data.frame(cm)
  # Sensitivity = True Positive / Actual Positive
  sensitivity <- (cm.df[cm.df$Actual == "YES" & cm.df$Predicted == "YES", 'Freq'])/sum(cm.df[cm.df$Actual == "YES","Freq"])
  # Specificity = True Negative / Actual Negative
  specificity <- (cm.df[cm.df$Actual == "NO" & cm.df$Predicted == "NO", "Freq"])/sum(cm.df[cm.df$Actual == "NO","Freq"])
  # Positive Predictive Value = True Positive / Predicted Positive
  ppv <- (cm.df[cm.df$Actual == "YES" & cm.df$Predicted == "YES", 'Freq'])/sum(cm.df[cm.df$Predicted == "YES","Freq"])
  # Negative Predictive Value = True Negative / Predicted Negative
  npv <- (cm.df[cm.df$Actual == "NO" & cm.df$Predicted == "NO", "Freq"])/sum(cm.df[cm.df$Predicted == "NO","Freq"])
  # Accuracy = (True Positive + True Negative) / (True Positive + True Negative + False Positive + False Negative)
  accuracy <- (cm.df[cm.df$Actual == "YES" & cm.df$Predicted == "YES", 'Freq'])/sum(cm.df$Freq)

  confusion <- list(cm=cm, sensitivity=sensitivity, specificity=specificity, ppv=ppv, npv=npv, accuracy=accuracy)
  return(confusion)
} # end of generateConfusionMatrix()

  
